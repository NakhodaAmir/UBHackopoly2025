<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Screen (Final Build)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Roboto', sans-serif; background-color: #1a1a2e; color: #e0e0e0; margin: 0; padding: 20px; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        
        
        .hidden { display: none !important; }
        .screen { width: 90%; max-width: 900px; padding: 30px; border: 2px solid #00e5ff; border-radius: 15px; background-color: #1f2a40; box-shadow: 0 0 20px rgba(0, 229, 255, 0.4); text-align: center; }
        .screen h1 { color: #fff; font-family: 'Press Start 2P', cursive; font-size: 2em; margin-bottom: 30px; }
        .button-primary { padding: 15px 40px; font-size: 1.3em; background-color: #00e5ff; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .button-primary:hover { background-color: #fff; box-shadow: 0 0 15px #00e5ff; }

        /* --- select stage --- */
        .stage-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .stage-select-button { padding: 20px; background-color: #3b4b6b; border: 2px solid #5a6b8b; color: white; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
        .stage-select-button:hover { background-color: #4c5d7e; border-color: #00e5ff; }
        .stage-select-button h3 { margin: 0 0 10px; color: #00e5ff; font-size: 1.2em; }
        .stage-select-button p { margin: 2px 0; color: #ccc; font-size: 0.9em; }
        .stage-select-button.final-boss { border-color: #ff4d4d; background-color: #b32d00; }
        .stage-select-button.final-boss:hover { border-color: #ff4d4d; background-color: #d90000; }

        /* --- level up --- */
        .level-up-screen .points-remaining { background-color: #00e5ff; color: #1f2a40; padding: 15px; border-radius: 8px; margin-bottom: 25px; font-weight: bold; display: inline-block; font-size: 1.2em; }
        .level-up-screen .points-remaining span { font-size: 2em; line-height: 1; display: block; margin-top: 5px; }
        .stat-allocation { display: flex; flex-direction: column; gap: 20px; margin-bottom: 30px; }
        .stat-control { display: flex; justify-content: space-between; align-items: center; background-color: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 8px; }
        .stat-control h3 { margin: 0; color: #00e5ff; font-size: 1.2em; }
        .stat-control .controls { display: flex; align-items: center; gap: 10px; }
        .stat-control .current-value { font-size: 1.5em; font-weight: bold; min-width: 80px; text-align: right; }
        .stat-control .added-value { color: #4dfc00; font-size: 1.2em; }
        .stat-control button { padding: 10px 15px; font-size: 1.2em; background-color: #4c5d7e; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .stat-control button:hover { background-color: #00e5ff; color: #1f2a40; }
        .stat-control button:disabled { background-color: #333; color: #777; cursor: not-allowed; }

        /* --- buttle --- */
        .battle-screen { width: 95%; max-width: 1400px; border-radius: 15px; background-color: #1f2a40; box-shadow: 0 0 30px rgba(0, 229, 255, 0.4); overflow: hidden; display: flex; flex-direction: column; }
        .battle-header { display: flex; justify-content: space-between; padding: 20px; background-color: rgba(0, 0, 0, 0.3); border-bottom: 1px solid #00e5ff; }
        .stats-block { width: 30%; background: rgba(10, 20, 40, 0.5); padding: 15px; border-radius: 8px; }
        .stats-block h2 { margin: 0 0 10px; color: #00e5ff; font-family: 'Press Start 2P', cursive; font-size: 16px; }
        .stats-block p { margin: 5px 0; font-size: 14px; }
        .stat-bar { width: 100%; background-color: #111; border-radius: 5px; overflow: hidden; height: 15px; border: 1px solid #555; }
        .hp-bar { background-color: #d90000; height: 100%; transition: width 0.5s ease; }
        .ap-bar { background-color: #007bff; height: 100%; transition: width 0.5s ease; }
        .battle-main { display: flex; padding: 20px; gap: 20px; }
        .action-palette { flex-basis: 15%; display: flex; flex-direction: column; gap: 10px; }
        .action-block {
            padding: 15px 10px;
            font-size: 1em;
            font-weight: bold;
            background-color: #3b4b6b;
            border: 2px solid #5a6b8b;
            color: #fff;
            border-radius: 5px;
            cursor: move;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s, border-color 0.2s, opacity 0.2s;
            justify-content: space-between;
        }

        .action-block i {
            font-style: italic;    
            font-size: 0.85em;    
            color: #ccc;        
            font-weight: normal;  
        }
        .action-block:hover { background-color: #4c5d7e; border-color: #00e5ff; }
        .action-block span { font-size: 1.2em; }
        .dragging { opacity: 0.5; border-style: dashed; }
        .center-area { flex-basis: 60%; display: flex; flex-direction: column; gap: 15px; }
        .battle-log { height: 120px; background-color: rgba(0, 0, 0, 0.5); border: 1px solid #445; border-radius: 5px; padding: 15px; overflow-y: auto; color: #ccc; margin-top: 10px; }
        .battle-log p { margin: 2px 0; }
        .battle-log .player-action { color: #00e5ff; font-weight: bold; }
        .battle-log .enemy-action { color: #ff4d4d; font-weight: bold; }
        .battle-log .system-message { color: #b3a400; font-style: italic; }
        .program-slots { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .slot { background-color: rgba(0, 0, 0, 0.3); border: 1px solid #445; border-radius: 8px; padding: 15px; }
        .slot h3 { margin: 0 0 10px; color: #aaa; }
        .drop-zone { min-height: 70px; background-color: rgba(0, 0, 0, 0.4); border: 2px dashed #00e5ff; border-radius: 5px; padding: 10px; display: flex; flex-direction: column; gap: 5px; color: #777; font-style: italic; justify-content: center; align-items: center; transition: background-color 0.3s, border-color 0.3s; }
        .drag-over { background-color: rgba(0, 229, 255, 0.2); border-color: #fff; }
        .dropped-block { padding: 10px; border-radius: 5px; color: white; font-family: 'Courier New', Courier, monospace; font-weight: bold; display: flex; align-items: center; gap: 8px; font-style: normal; width: 90%; justify-content: center; }
        .attack-block { background-color: #b32d00; }
        .charge-block { background-color: #d97400; }
        .heal-block { background-color: #006ddb; }
        .defend-block { background-color: #005a8a; }
        .counter-block { background-color: #8a00b3; }
        .focus-block { background-color: #ffffff; color: #1a1a2e; }
        .cleanse-block { background-color: #4dfc00; color: #1a1a2e; }
        .kill-block { background-color: #111; color: #ff4d4d; border: 1px solid #ff4d4d; }
        
        .info-sidebar { flex-basis: 25%; padding: 15px; background-color: rgba(0, 0, 0, 0.3); border-radius: 8px; border: 1px solid #445; }
        .info-sidebar h3 { margin: 0 0 10px; color: #00e5ff; font-family: 'Press Start 2P', cursive; font-size: 14px; }
        .buff-list { list-style: none; padding: 0; }
        .buff-list li { background: #3b4b6b; padding: 8px; border-radius: 4px; margin-bottom: 5px; }
        .debuff { background: #b32d00; color: white; }
        .battle-footer { text-align: center; padding: 20px; background-color: rgba(0, 0, 0, 0.3); border-top: 1px solid #00e5ff; }
        .execute-button, .item-button { padding: 15px 30px; font-size: 1.3em; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .execute-button { background-color: #00e5ff; color: #1a1a2e; }
        .execute-button:hover { background-color: #fff; box-shadow: 0 0 15px #00e5ff; }
        .execute-button:disabled, .item-button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        .return-button { padding: 10px 20px; font-size: 1em; background-color: #5a6b8b; color: #fff; border: none; border-radius: 5px; cursor: pointer; margin-left: 15px; font-weight: bold; }
        .return-button:hover { background-color: #4c5d7e; }
        .item-button { background-color: #4dfc00; color: #1a1a2e; margin-right: 15px; }

        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: #1f2a40; border: 2px solid #00e5ff; border-radius: 10px; padding: 30px; width: 80%; max-width: 500px; text-align: center; box-shadow: 0 0 20px rgba(0, 229, 255, 0.5); }
        .modal-content p { font-size: 1.2em; margin: 0 0 20px; line-height: 1.6; }
        .modal-button { padding: 10px 30px; font-size: 1em; background-color: #00e5ff; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        
        /* items */
        .item-modal-list { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
        .item-modal-list li { margin-bottom: 10px; }
        .item-modal-button { background-color: #3b4b6b; color: white; border: 1px solid #5a6b8b; padding: 15px; width: 100%; border-radius: 5px; cursor: pointer; text-align: left; }
        .item-modal-button:hover { border-color: #00e5ff; }
        .item-modal-button p { font-size: 0.9em; color: #ccc; margin: 5px 0 0; }
    </style>
</head>
<body>

    <div class="screen" id="stage-selection-screen">
        <h1>Select Stage</h1>
        <div class="stage-grid">
            <button class="stage-select-button" data-stage-id="stage1"><h3>Stage 1</h3><p>Enemies: Lv. 1</p></button>
            <button class="stage-select-button" data-stage-id="stage2"><h3>Stage 2</h3><p>Enemies: Lv. 1, Lv. 2</p></button>
            <button class="stage-select-button" data-stage-id="stage3"><h3>Stage 3</h3><p>Enemies: Lv. 2, Lv. 3</p></button>
            <button class="stage-select-button" data-stage-id="stage4"><h3>Stage 4</h3><p>Enemies: Lv. 3, Lv. 4</p></button>
            <button class="stage-select-button" data-stage-id="stage5"><h3>Stage 5</h3><p>Enemies: Lv. 4, Lv. 5</p></button>
            <button class="stage-select-button final-boss" data-stage-id="final"><h3>FINAL</h3><p>Enemies: BOSS</p></button>
        </div>
    </div>
    
    <div class="screen hidden" id="level-up-screen">
        <h1>Victory!</h1>
        <div class="points-remaining">
            <p>Points to Allocate:</p>
            <span id="points-remaining-text">50</span>
        </div>
        <div class="stat-allocation">
            <div class="stat-control">
                <h3>HP ‚úö</h3>
                <div class="controls">
                    <button id="hp-minus-btn">-</button>
                    <span class="current-value" id="hp-current-text">100</span>
                    <span class="added-value" id="hp-added-text">(+0)</span>
                    <button id="hp-plus-btn">+</button>
                </div>
            </div>
            <div class="stat-control">
                <h3>Attack ‚öîÔ∏è</h3>
                <div class="controls">
                    <button id="atk-minus-btn">-</button>
                    <span class="current-value" id="atk-current-text">30</span>
                    <span class="added-value" id="atk-added-text">(+0)</span>
                    <button id="atk-plus-btn">+</button>
                </div>
            </div>
            <div class="stat-control">
                <h3>Speed üí®</h3>
                <div class="controls">
                    <button id="spd-minus-btn">-</button>
                    <span class="current-value" id="spd-current-text">50</span>
                    <span class="added-value" id="spd-added-text">(+0)</span>
                    <button id="spd-plus-btn">+</button>
                </div>
            </div>
        </div>
        <button class="button-primary" id="confirm-stats-button">Confirm & Return</button>
    </div>


    <div class="battle-screen hidden" id="battle-screen">
        
        <header class="battle-header">
            <div class="stats-block" id="player-stats-block">
                <h2>Player Hero</h2>
                <p id="player-hp-text">HP: 100 / 100</p>
                <div class="stat-bar"><div class="hp-bar" id="player-hp-bar"></div></div>
                <p id="player-ap-text">AP: 8 / 8</p>
                <div class="stat-bar"><div class="ap-bar" id="player-ap-bar"></div></div>
                <p id="player-atk-text">ATK: 30</p>
                <p id="player-spd-text">SPD: 50</p>
            </div>
            
            <div class="stats-block" id="enemy-stats-block">
                <h2 id="enemy-name-text">Enemy AI</h2>
                <p id="enemy-hp-text">HP: ??? / ???</p>
                <div class="stat-bar"><div class="hp-bar" id="enemy-hp-bar"></div></div>
                <p id="enemy-ap-text">AP: 8 / 8</p>
                <div class="stat-bar"><div class="ap-bar" id="enemy-ap-bar"></div></div>
                <p id="enemy-atk-text">ATK: ???</p>
                <p id="enemy-spd-text">SPD: ???</p>
            </div>
        </header>

        <main class="battle-main">
            <aside class="action-palette">
                <button class="action-block" data-action="ATTACK" draggable="true"><span>‚öîÔ∏è</span> ATTACK <i>AP 2</i></button>
                <button class="action-block" data-action="CHARGE" draggable="true"><span>‚ö°</span> CHARGE <i>AP 1</i></button>
                <button class="action-block" data-action="HEAL" draggable="true"><span>‚úö</span> HEAL <i>AP 4</i></button>
                <button class="action-block" data-action="DEFEND" draggable="true"><span>üõ°Ô∏è</span> DEFEND <i>AP 1</i></button>
                <button class="action-block" data-action="COUNTER" draggable="true"><span>üîÑ</span> COUNTER <i>AP 3</i></button>
                <button class="action-block" data-action="CLEANSE" draggable="true"><span>‚ú®</span> CLEANSE <i>AP 4</i></button>
                <button class="action-block" data-action="FOCUS" draggable="true"><span>üßò</span> FOCUS <i>AP 0</i></button>
                
                <hr style="border-color: #5a6b8b;">
                <button class="action-block kill-block" data-action="KILL" draggable="true"><span>‚ò†Ô∏è</span> DEV: KILL </button>
            </aside>

            <div class="center-area">
                <div class="battle-log" id="battle-log">
                    <p class="system-message">System ready. Drag 4 actions to the slots.</p>
                </div>
                <div class="program-slots">
                    <div class="slot" id="slot-1"><div class="drop-zone" data-slot-id="1">[1st Action]</div></div>
                    <div class="slot" id="slot-2"><div class="drop-zone" data-slot-id="2">[2nd Action]</div></div>
                    <div class="slot" id="slot-3"><div class="drop-zone" data-slot-id="3">[3rd Action]</div></div>
                    <div class="slot" id="slot-4"><div class="drop-zone" data-slot-id="4">[4th Action]</div></div>
                </div>
            </div>

            <aside class="info-sidebar">
                <h3>Player Buffs/Debuffs</h3>
                <ul class="buff-list" id="player-buff-list">
                    <li>(No active effects)</li>
                </ul>
                <h3>Enemy Buffs/Debuffs</h3>
                <ul class="buff-list" id="enemy-buff-list">
                    <li>(No active effects)</li>
                </ul>
                <h3 style="margin-top: 20px;">Inventory</h3>
                <ul class="buff-list" id="inventory-list">
                    <li>(Empty)</li>
                </ul>
            </aside>
        </main>

        <footer class="battle-footer">
            <button class="item-button" id="use-item-button">USE ITEM</button>
            <button class="button-primary execute-button" id="execute-turn">EXECUTE TURN</button>
            <button class="return-button" id="return-to-stages">Return to Stages</button>
        </footer>
    </div>
    
    <div class="modal-overlay hidden" id="item-modal-overlay">
        <div class="modal-content">
            <h2>Inventory</h2>
            <ul class="item-modal-list" id="item-modal-list">
                </ul>
            <button class="modal-button" id="close-item-modal">Close</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. data slot ---
            const logicSlots = { "1": null, "2": null, "3": null, "4": null };
            let isBattleOver = false;
            let turnCount = 0; 

            // status of player
            const playerBaseStats = { maxHp: 100, attack: 30, speed: 50 };
            
            const player = {
                name: "Player", ...playerBaseStats, currentHp: 100, maxAp: 8, currentAp: 8,
                chargeTurns: 0, isDefending: false, isCountering: false, isPoisoned: false, isStunned: false, isVulnerable: false,
                speedBuffTurns: 0, speedDebuffTurns: 0, speedBuffPercent: 0, speedDebuffPercent: 0
            };
            
            let enemy = {}; 
            
            
            let playerInventory = []; 
            
            // items
            const ITEM_DATABASE = {
                "mini_health_potion": { 
                    name: "Mini Health Potion", rarity: 'common', description: "Restores 50 HP.",
                    effect: (actor) => {
                        actor.currentHp = Math.min(actor.maxHp, actor.currentHp + 50);
                        return "Player healed for 50 HP.";
                    }
                },
                "mega_health_potion": { 
                    name: "Mega Health Potion", rarity: 'rare', description: "Restores 150 HP.",
                    effect: (actor) => {
                        actor.currentHp = Math.min(actor.maxHp, actor.currentHp + 150);
                        return "Player healed for 150 HP.";
                    }
                },
                "cleanse_potion": {
                    name: "Cleanse Potion", rarity: 'common', description: "Clears all debuffs.",
                    effect: (actor) => {
                        actor.isPoisoned = false; 
                        actor.isStunned = false; 
                        actor.isVulnerable = false;
                        actor.speedDebuffTurns = 0; 
                        actor.speedDebuffPercent = 0;
                        return "Player's debuffs were cleansed.";
                    }
                },
                "ap_potion": {
                    name: "AP Potion", rarity: 'common', description: "Restores 1 AP.",
                    effect: (actor) => {
                        actor.currentAp = Math.min(actor.maxAp, actor.currentAp + 1);
                        return "Player restored 1 AP.";
                    }
                },
                "speed_potion": {
                    name: "Speed Potion", rarity: 'rare', description: "Increases Speed by 30% for 3 turns.",
                    effect: (actor) => {
                        actor.speedBuffTurns = 3; actor.speedBuffPercent = 0.30;
                        return "Player Speed increased by 30%!";
                    }
                },
                "spider_web": {
                    name: "Spider Web", rarity: 'rare', description: "Reduces enemy Speed by 40% for 1 turn.",
                    effect: (target) => {
                        target.speedDebuffTurns = 1; target.speedDebuffPercent = 0.40;
                        return "Enemy Speed reduced by 40%.";
                    }
                },
                "spikes": {
                    name: "Spikes", rarity: 'rare', description: "Reduces enemy Speed by 25% for 3 turns.",
                    effect: (target) => {
                        target.speedDebuffTurns = 3; target.speedDebuffPercent = 0.25;
                        return "Enemy Speed reduced by 25% for 3 turns.";
                    }
                }
            };

            const ACTIONS = {
                "ATTACK": { cost: 2, bonus: 10 },
                "CHARGE": { cost: 1, percent: 0.20, turns: 3 },
                "HEAL": { cost: 4, percent: 0.20 }, 
                "DEFEND": { cost: 1, reduction: 0.80 }, 
                "COUNTER": { cost: 3, multiplier: 1.5, penalty: 0.20 },
                "CLEANSE": { cost: 4 },
                "FOCUS": { cost: 0, amount: 4 },
                "KILL": { cost: 0 },
                "POISON_ATTACK": { cost: 3, bonus: 5 },
                "STUN_ATTACK": { cost: 3, bonus: 10 },
                "VULN_ATTACK": { cost: 2, bonus: 5 }
            };
            
            const MAX_AP = 8;
            const AP_RECOVERY = 4;

            // --- enemy ai ---
            const ai_l1_attack = () => { if (enemy.currentHp < enemy.maxHp * 0.5 && enemy.currentAp >= ACTIONS.HEAL.cost) return "HEAL"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l1_defend = () => { if (enemy.currentHp < enemy.maxHp * 0.8 && enemy.currentAp >= ACTIONS.HEAL.cost) return "HEAL"; if (enemy.currentAp >= ACTIONS.DEFEND.cost) return "DEFEND"; return "FOCUS"; };
            const ai_l2_attack = () => { if (enemy.chargeTurns === 0 && enemy.currentAp >= ACTIONS.CHARGE.cost) return "CHARGE"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l2_defend = () => { if (enemy.currentAp === enemy.maxAp && enemy.currentAp >= ACTIONS.DEFEND.cost) return "DEFEND"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l3_poison = () => { if (!player.isPoisoned && enemy.currentAp >= ACTIONS.POISON_ATTACK.cost) return "POISON_ATTACK"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l3_defend = () => { if (!player.isVulnerable && enemy.currentAp >= ACTIONS.VULN_ATTACK.cost) return "VULN_ATTACK"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l4_stun = () => { if (enemy.currentHp < enemy.maxHp * 0.3 && enemy.currentAp >= ACTIONS.DEFEND.cost) return "DEFEND"; if (turnCount % 3 === 0 && !player.isStunned && enemy.currentAp >= ACTIONS.STUN_ATTACK.cost) return "STUN_ATTACK"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l4_defend = () => { if (enemy.currentHp < enemy.maxHp * 0.3 && enemy.currentAp >= ACTIONS.HEAL.cost) return "HEAL"; if (enemy.currentHp > enemy.maxHp * 0.8 && enemy.currentAp >= ACTIONS.DEFEND.cost) return "DEFEND"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l5_attack = () => { if ((player.isDefending || player.isCountering) && !player.isStunned && enemy.currentAp >= ACTIONS.STUN_ATTACK.cost) return "STUN_ATTACK"; if (enemy.chargeTurns === 0 && enemy.currentAp >= ACTIONS.CHARGE.cost) return "CHARGE"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_l5_defend = () => { const playerHasStatus = player.isPoisoned || player.isStunned || player.isVulnerable; if (playerHasStatus && !player.isVulnerable && enemy.currentAp >= ACTIONS.VULN_ATTACK.cost) return "VULN_ATTACK"; if (enemy.currentHp < enemy.maxHp * 0.6 && enemy.currentAp >= ACTIONS.DEFEND.cost) return "DEFEND"; if (enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; return "FOCUS"; };
            const ai_boss_1 = () => { const playerHasStatus = player.isPoisoned || player.isStunned || player.isVulnerable; if ((player.isDefending || player.isCountering) && enemy.chargeTurns === 0 && enemy.currentAp >= ACTIONS.CHARGE.cost) return "CHARGE"; if (playerHasStatus && enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; const options = ["STUN_ATTACK", "POISON_ATTACK", "VULN_ATTACK", "ATTACK"]; const available = options.filter(a => enemy.currentAp >= ACTIONS[a].cost); return available[Math.floor(Math.random() * available.length)] || "FOCUS"; };
            const ai_boss_2 = () => { if (enemy.currentHp < 100 && enemy.currentAp >= ACTIONS.HEAL.cost) return "HEAL"; if (enemy.currentHp > 100 && enemy.currentHp <= 150 && enemy.currentAp >= ACTIONS.ATTACK.cost) return "ATTACK"; const options = ["STUN_ATTACK", "POISON_ATTACK", "VULN_ATTACK"]; const available = options.filter(a => enemy.currentAp >= ACTIONS[a].cost); return available[Math.floor(Math.random() * available.length)] || "FOCUS"; };
            
            // --- enemy database ---
            const ENEMY_DATABASE = {
                "l1_attack": { name: "L1: Attack Slime", maxHp: 40, currentHp: 40, attack: 60, speed: 50, aiLogic: ai_l1_attack, lootTable: ["mini_health_potion", "ap_potion"] },
                "l1_defend": { name: "L1: Defend Turtle", maxHp: 60, currentHp: 60, attack: 40, speed: 50, aiLogic: ai_l1_defend, lootTable: ["mini_health_potion", "cleanse_potion"] },
                "l2_attack": { name: "L2: Buff Goblin", maxHp: 50, currentHp: 50, attack: 65, speed: 60, aiLogic: ai_l2_attack, lootTable: ["mini_health_potion", "ap_potion"] },
                "l2_defend": { name: "L2: Heavy Knight", maxHp: 95, currentHp: 95, attack: 40, speed: 40, aiLogic: ai_l2_defend, lootTable: ["cleanse_potion"] },
                "l3_poison": { name: "L3: Poison Viper", maxHp: 50, currentHp: 50, attack: 70, speed: 80, aiLogic: ai_l3_poison, lootTable: ["cleanse_potion", "spider_web"] },
                "l3_defend": { name: "L3: Vuln Tortoise", maxHp: 70, currentHp: 70, attack: 80, speed: 50, aiLogic: ai_l3_defend, lootTable: ["mini_health_potion", "spikes"] },
                "l4_stun": { name: "L4: Stun Golem", maxHp: 55, currentHp: 55, attack: 100, speed: 70, aiLogic: ai_l4_stun, lootTable: ["mega_health_potion", "speed_potion"] },
                "l4_defend": { name: "L4: Ancient Guard", maxHp: 125, currentHp: 125, attack: 50, speed: 50, aiLogic: ai_l4_defend, lootTable: ["mega_health_potion", "ap_potion"] },
                "l5_attack": { name: "L5: Chaos Knight", maxHp: 70, currentHp: 70, attack: 100, speed: 80, aiLogic: ai_l5_attack, lootTable: ["speed_potion", "spikes"] },
                "l5_defend": { name: "L5: Oracle", maxHp: 110, currentHp: 110, attack: 70, speed: 70, aiLogic: ai_l5_defend, lootTable: ["mega_health_potion", "spider_web"] },
                "boss_1": { name: "FINAL BOSS (Atk)", maxHp: 200, currentHp: 200, attack: 120, speed: 80, aiLogic: ai_boss_1, lootTable: [] },
                "boss_2": { name: "FINAL BOSS (Def)", maxHp: 250, currentHp: 250, attack: 70, speed: 80, aiLogic: ai_boss_2, lootTable: [] }
            };
            
            const STAGE_DATABASE = {
                "stage1": ["l1_attack", "l1_defend"],
                "stage2": ["l1_attack", "l1_defend", "l2_attack", "l2_defend"],
                "stage3": ["l2_attack", "l2_defend", "l3_poison", "l3_defend"],
                "stage4": ["l3_poison", "l3_defend", "l4_stun", "l4_defend"],
                "stage5": ["l4_stun", "l4_defend", "l5_attack", "l5_defend"],
                "final": ["boss_1", "boss_2"]
            };

            // --- 2. get html ---
            const stageSelectionScreen = document.getElementById('stage-selection-screen');
            const levelUpScreen = document.getElementById('level-up-screen'); 
            const battleScreen = document.getElementById('battle-screen');
            const stageSelectButtons = document.querySelectorAll('.stage-select-button');
            const executeButton = document.getElementById('execute-turn');
            const returnButton = document.getElementById('return-to-stages');
            const useItemButton = document.getElementById('use-item-button'); 
            const itemModalOverlay = document.getElementById('item-modal-overlay'); 
            const itemModalList = document.getElementById('item-modal-list');
            const closeItemModalButton = document.getElementById('close-item-modal');
            const actionPaletteButtons = document.querySelectorAll('.action-palette .action-block');
            const dropZones = document.querySelectorAll('.drop-zone');
            const battleLog = document.getElementById('battle-log');
            const playerHpText = document.getElementById('player-hp-text');
            const playerHpBar = document.getElementById('player-hp-bar');
            const playerApText = document.getElementById('player-ap-text');
            const playerApBar = document.getElementById('player-ap-bar');
            const playerAtkText = document.getElementById('player-atk-text');
            const playerSpdText = document.getElementById('player-spd-text');
            const enemyNameText = document.getElementById('enemy-name-text');
            const enemyHpText = document.getElementById('enemy-hp-text');
            const enemyHpBar = document.getElementById('enemy-hp-bar');
            const enemyApText = document.getElementById('enemy-ap-text');
            const enemyApBar = document.getElementById('enemy-ap-bar');
            const enemyAtkText = document.getElementById('enemy-atk-text');
            const enemySpdText = document.getElementById('enemy-spd-text');
            const playerBuffList = document.getElementById('player-buff-list');
            const enemyBuffList = document.getElementById('enemy-buff-list');
            const inventoryList = document.getElementById('inventory-list'); 

            // --- 3. support functions ---
            
            function showActionPopup(message) {
                return new Promise(resolve => {
                    const overlay = document.createElement('div');
                    overlay.className = 'modal-overlay';
                    const modal = document.createElement('div');
                    modal.className = 'modal-content';
                    const text = document.createElement('p');
                    text.innerHTML = message; 
                    const okButton = document.createElement('button');
                    okButton.className = 'modal-button';
                    okButton.textContent = 'OK';
                    modal.appendChild(text);
                    modal.appendChild(okButton);
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    okButton.onclick = () => { document.body.removeChild(overlay); resolve(); };
                });
            }
            
            function logToScreen(message, type = 'system') {
                if (!battleLog) return;
                const p = document.createElement('p');
                p.textContent = message;
                p.className = `${type}-message`;
                battleLog.appendChild(p);
                battleLog.scrollTop = battleLog.scrollHeight;
            }

            function updateUI() {
                // Player
                player.currentHp = Math.max(0, player.currentHp);
                player.maxHp = playerBaseStats.maxHp; 
                player.attack = playerBaseStats.attack;
                player.speed = playerBaseStats.speed;
                playerHpText.textContent = `HP: ${player.currentHp} / ${player.maxHp}`;
                playerHpBar.style.width = `${(player.currentHp / player.maxHp) * 100}%`;
                playerApText.textContent = `AP: ${player.currentAp} / ${player.maxAp}`;
                playerApBar.style.width = `${(player.currentAp / player.maxAp) * 100}%`;
                playerAtkText.textContent = `ATK: ${player.attack} (${getEffectiveSpeed(player)} SPD)`; 
                playerSpdText.textContent = ``;

                // Enemy
                if (enemy.maxHp) { 
                    enemy.currentHp = Math.max(0, enemy.currentHp);
                    enemyNameText.textContent = enemy.name;
                    enemyHpText.textContent = `HP: ${enemy.currentHp} / ${enemy.maxHp}`;
                    enemyHpBar.style.width = `${(enemy.currentHp / enemy.maxHp) * 100}%`;
                    enemyApText.textContent = `AP: ${enemy.currentAp} / ${enemy.maxAp}`;
                    enemyApBar.style.width = `${(enemy.currentAp / enemy.maxAp) * 100}%`;
                    enemyAtkText.textContent = `ATK: ${enemy.attack} (${getEffectiveSpeed(enemy)} SPD)`;
                    enemySpdText.textContent = ``;
                }
                
                playerBuffList.innerHTML = ''; 
                if (player.chargeTurns > 0) playerBuffList.innerHTML += `<li>ATK UP - ${player.chargeTurns} Turns</li>`;
                if (player.speedBuffTurns > 0) playerBuffList.innerHTML += `<li>SPD UP (${player.speedBuffPercent*100}%) - ${player.speedBuffTurns} Turns</li>`;
                if (player.isPoisoned) playerBuffList.innerHTML += `<li class="debuff">POISONED</li>`;
                if (player.isStunned) playerBuffList.innerHTML += `<li class="debuff">STUNNED</li>`;
                if (player.isVulnerable) playerBuffList.innerHTML += `<li class="debuff">VULNERABLE</li>`;
                if (player.speedDebuffTurns > 0) playerBuffList.innerHTML += `<li class="debuff">SPD DOWN (${player.speedDebuffPercent*100}%) - ${player.speedDebuffTurns} Turns</li>`;
                if (!playerBuffList.innerHTML) playerBuffList.innerHTML = `<li>(No active effects)</li>`;
                
                enemyBuffList.innerHTML = ''; 
                if (enemy.chargeTurns > 0) enemyBuffList.innerHTML += `<li>ATK UP - ${enemy.chargeTurns} Turns</li>`;
                if (enemy.speedBuffTurns > 0) enemyBuffList.innerHTML += `<li>SPD UP (${enemy.speedBuffPercent*100}%) - ${enemy.speedBuffTurns} Turns</li>`;
                if (enemy.isPoisoned) enemyBuffList.innerHTML += `<li class="debuff">POISONED</li>`;
                if (enemy.isStunned) enemyBuffList.innerHTML += `<li class="debuff">STUNNED</li>`;
                if (enemy.isVulnerable) enemyBuffList.innerHTML += `<li class="debuff">VULNERABLE</li>`;
                if (enemy.speedDebuffTurns > 0) enemyBuffList.innerHTML += `<li class="debuff">SPD DOWN (${enemy.speedDebuffPercent*100}%) - ${enemy.speedDebuffTurns} Turns</li>`;
                if (!enemyBuffList.innerHTML) enemyBuffList.innerHTML = `<li>(No active effects)</li>`;

                inventoryList.innerHTML = '';
                const counts = {};
                playerInventory.forEach(item => { counts[item] = (counts[item] || 0) + 1; });
                if (Object.keys(counts).length === 0) {
                    inventoryList.innerHTML = `<li>(Empty)</li>`;
                } else {
                    for (const item in counts) {
                        inventoryList.innerHTML += `<li>${ITEM_DATABASE[item].name} x ${counts[item]}</li>`;
                    }
                }
            }

            function resetSlots() {
                dropZones.forEach(zone => {
                    zone.innerHTML = `[${zone.dataset.slotId}st Action]`;
                    logicSlots[zone.dataset.slotId] = null;
                });
            }
            
            function getEffectiveSpeed(actor) {
                let speed = actor.speed;
                if (actor.speedBuffTurns > 0) speed *= (1 + actor.speedBuffPercent);
                if (actor.speedDebuffTurns > 0) speed *= (1 - actor.speedDebuffPercent);
                return Math.floor(speed);
            }

            // --- 4. drag and drop ---
            actionPaletteButtons.forEach(block => {
                block.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', block.dataset.action);
                    block.classList.add('dragging');
                });
                block.addEventListener('dragend', () => block.classList.remove('dragging'));
            });

            dropZones.forEach(zone => {
                zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('drag-over'); });
                zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    const actionName = e.dataTransfer.getData('text/plain');
                    const slotId = zone.dataset.slotId;
                    logicSlots[slotId] = actionName; 
                    zone.innerHTML = '';
                    const droppedBlock = document.createElement('div');
                    let styleClass = actionName.toLowerCase() + '-block';
                    droppedBlock.className = `dropped-block ${styleClass}`;
                    droppedBlock.textContent = actionName;
                    zone.appendChild(droppedBlock);
                });
            });

            // --- 5. enemy logic ---
            function getEnemyAction() {
                const plannedAction = enemy.aiLogic();
                if (enemy.currentAp < (ACTIONS[plannedAction]?.cost || 0)) {
                    return "FOCUS";
                }
                return plannedAction;
            }

            // --- 6. botten ---
            executeButton.addEventListener('click', async () => {
                if (isBattleOver) {
                    await showActionPopup("Battle is over. Please refresh to restart.");
                    return;
                }
                if (Object.values(logicSlots).some(action => action === null)) {
                    await showActionPopup("Please fill all 4 action slots before executing.");
                    return;
                }

                executeButton.disabled = true;
                returnButton.disabled = true; 
                useItemButton.disabled = true;
                logToScreen("--- TURN START ---", 'system');
                turnCount++; 

                for (let i = 1; i <= 4; i++) {
                    if (isBattleOver) break;
                    const playerAction = logicSlots[i];
                    const enemyAction = getEnemyAction(); 
                    
                    const playerGoesFirst = getEffectiveSpeed(player) >= getEffectiveSpeed(enemy);
                    
                    const actionsInOrder = playerGoesFirst 
                        ? [{ actor: player, action: playerAction, target: enemy, name: "Player" },
                           { actor: enemy, action: enemyAction, target: player, name: "Enemy" }]
                        : [{ actor: enemy, action: enemyAction, target: player, name: "Enemy" },
                           { actor: player, action: playerAction, target: enemy, name: "Player" }];
                    for (const turn of actionsInOrder) {
                        if (isBattleOver) break;
                        await processAction(turn.actor, turn.target, turn.action, turn.name);
                    }
                }

                if (!isBattleOver) {
                    await endTurn(); 
                    logToScreen("--- WAITING FOR NEXT 4 ACTIONS ---", 'system');
                    executeButton.disabled = false;
                    returnButton.disabled = false;
                    useItemButton.disabled = false;
                    resetSlots();
                }
            });

            // --- 7. action logics ---
            async function processAction(actor, target, action, actorName) {
                if (actor.currentHp <= 0) return; 
                if (actor.isStunned) {
                    actor.isStunned = false; 
                    updateUI();
                    await showActionPopup(`<strong>${actorName} is STUNNED</strong> and cannot act!`);
                    return;
                }

                const actionSpec = ACTIONS[action];
                if (!actionSpec) {
                    await showActionPopup(`${actorName} skipped action.`);
                    return;
                }
                if (actor.currentAp < actionSpec.cost) {
                    await showActionPopup(`${actorName} failed ${action} (Not enough AP)`);
                    return;
                }
                actor.currentAp -= actionSpec.cost;

                let logMessage = `<strong>${actorName}</strong> used <strong>${action}</strong>. `;
                
                switch(action) {
                    case "ATTACK":
                        let damage = actor.attack + actionSpec.bonus;
                        if (actor.chargeTurns > 0) damage *= (1 + ACTIONS.CHARGE.percent);
                        damage = Math.floor(damage);
                        if (target.isVulnerable) damage *= 2; 
                        if (target.isDefending) {
                            damage = Math.floor(damage * (1 - ACTIONS.DEFEND.reduction)); 
                            logMessage += `${target.name} DEFENDED! `;
                        } else if (target.isCountering) {
                            const counterDamage = Math.floor(damage * ACTIONS.COUNTER.multiplier);
                            actor.currentHp -= counterDamage;
                            logMessage += `${target.name} COUNTERED! ${actorName} takes ${counterDamage} damage! `;
                            damage = 0;
                        }
                        target.currentHp -= damage;
                        logMessage += `Dealt ${damage} damage.`;
                        break;
                    case "CHARGE":
                        case "CLEANSE":
                        actor.isPoisoned = false;
                        actor.isStunned = false;
                        actor.isVulnerable = false;
                        actor.speedDebuffTurns = 0; 
                        actor.speedDebuffPercent = 0;
                        logMessage += `Status normalized.`;
                        break;
                    case "HEAL":
                        const healAmount = Math.floor(actor.maxHp * actionSpec.percent);
                        actor.currentHp = Math.min(actor.maxHp, actor.currentHp + healAmount);
                        logMessage += `Healed ${healAmount} HP (20%).`;
                        break;
                    case "DEFEND":
                        actor.isDefending = true; 
                        logMessage += `Prepares to defend.`;
                        break;
                    case "COUNTER":
                        actor.isCountering = true;
                        const targetAction = (actorName === 'Player') ? getEnemyAction() : logicSlots[Object.keys(logicSlots).find(k => logicSlots[k])];
                        if (!targetAction.includes('ATTACK')) { 
                             const penalty = Math.floor(actor.maxHp * ACTIONS.COUNTER.penalty);
                             actor.currentHp -= penalty;
                             logMessage += `FAILED COUNTER! Takes ${penalty} self-damage.`;
                        } else {
                            logMessage += `Prepares to counter.`;
                        }
                        break;
                    case "CLEANSE":
                        actor.isPoisoned = false;
                        actor.isStunned = false;
                        actor.isVulnerable = false;
                        actor.speedDebuffTurns = 0; actor.speedDebuffPercent = 0;
                        logMessage += `Status normalized.`;
                        break;
                    case "FOCUS":
                        actor.currentAp = Math.min(actor.maxAp, actor.currentAp + actionSpec.amount);
                        logMessage += `Recovered ${actionSpec.amount} AP.`;
                        break;
                    
                    case "POISON_ATTACK":
                        if (target.isDefending) {
                            logMessage += `${target.name} DEFENDED the POISON!`;
                        } else if (target.isCountering) {
                            actor.isPoisoned = true; 
                            logMessage += `${target.name} COUNTERED! The POISON is reflected!`;
                        } else {
                            target.isPoisoned = true;
                            logMessage += `Attacks and inflicts POISON!`;
                        }
                        break;
                    case "STUN_ATTACK":
                        if (target.isDefending) {
                            logMessage += `${target.name} DEFENDED the STUN!`;
                        } else if (target.isCountering) {
                            actor.isStunned = true; 
                            logMessage += `${target.name} COUNTERED! The STUN is reflected!`;
                        } else {
                            target.isStunned = true;
                            logMessage += `Attacks and inflicts STUN!`;
                        }
                        break;
                    case "VULN_ATTACK":
                         if (target.isDefending) {
                            logMessage += `${target.name} DEFENDED the VULNERABILITY!`;
                        } else if (target.isCountering) {
                            actor.isVulnerable = true; 
                            logMessage += `${target.name} COUNTERED! The VULNERABILITY is reflected!`;
                        } else {
                            target.isVulnerable = true;
                            logMessage += `Attacks and inflicts VULNERABLE!`;
                        }
                        break;
                    
                    case "KILL":
                        target.currentHp = 0;
                        logMessage += `[DEV] Used KILL. Target annihilated.`;
                        break;
                }
                
                if (actorName === 'Player') {
                    enemy.isDefending = false;
                    enemy.isCountering = false;
                } else {
                    player.isDefending = false;
                    player.isCountering = false;
                }

                await showActionPopup(logMessage);
                logToScreen(logMessage.replace(/<[^>]*>/g, ''), actorName === 'Player' ? 'player' : 'enemy'); 
                updateUI();
                checkWinCondition();
            }
            
            // --- 8. turn end ---
            async function endTurn() {
                let turnEndMessage = "--- End of Turn ---<br>";
                player.currentAp = Math.min(MAX_AP, player.currentAp + AP_RECOVERY);
                enemy.currentAp = Math.min(MAX_AP, enemy.currentAp + AP_RECOVERY);
                turnEndMessage += `AP recovered (+${AP_RECOVERY}).<br>`;
                
                if (player.chargeTurns > 0) player.chargeTurns--;
                if (player.speedBuffTurns > 0) player.speedBuffTurns--;
                if (player.speedDebuffTurns > 0) player.speedDebuffTurns--;
                if (enemy.chargeTurns > 0) enemy.chargeTurns--;
                if (enemy.speedBuffTurns > 0) enemy.speedBuffTurns--;
                if (enemy.speedDebuffTurns > 0) enemy.speedDebuffTurns--;
                
                if (player.speedBuffTurns === 0) player.speedBuffPercent = 0;
                if (player.speedDebuffTurns === 0) player.speedDebuffPercent = 0;
                if (enemy.speedBuffTurns === 0) enemy.speedBuffPercent = 0;
                if (enemy.speedDebuffTurns === 0) enemy.speedDebuffPercent = 0;
                
                if (player.isPoisoned) {
                    const poisonDmg = Math.floor(player.maxHp * 0.05);
                    player.currentHp -= poisonDmg;
                    turnEndMessage += `Player takes ${poisonDmg} poison damage.<br>`;
                }
                if (enemy.isPoisoned) {
                    const poisonDmg = Math.floor(enemy.maxHp * 0.05);
                    enemy.currentHp -= poisonDmg;
                    turnEndMessage += `Enemy takes ${poisonDmg} poison damage.<br>`;
                }
                
                await showActionPopup(turnEndMessage); 
                logToScreen("Turn ended. AP and effects processed.", "system");
                updateUI();
                checkWinCondition();
            }

            // --- 9. judge ---
            async function checkWinCondition() {
                if (isBattleOver) return;

                if (enemy.currentHp <= 0) {
                    isBattleOver = true;
                    executeButton.disabled = true;
                    returnButton.disabled = true;

                    await showActionPopup("--- üéâ YOU WIN! üéâ ---");
                    
                    const droppedItems = handleLootDrop(); 
                    if (droppedItems.length > 0) {
                        let lootMessage = "Enemy dropped:<br>";
                        for (const itemID of droppedItems) {
                            lootMessage += `<strong>${ITEM_DATABASE[itemID].name}</strong><br>`;
                        }
                        await showActionPopup(lootMessage);
                    }
                    
                    showLevelUpScreen();

                } else if (player.currentHp <= 0) {
                    isBattleOver = true;
                    executeButton.disabled = true;
                    returnButton.disabled = true;
                    await showActionPopup("--- ‚ò†Ô∏è YOU LOSE... ‚ò†Ô∏è ---<br>Returning to Stage Select.");
                    
                    battleScreen.classList.add('hidden');
                    stageSelectionScreen.classList.remove('hidden');
                }
            }
            function handleLootDrop() {
                console.log("Checking loot for:", enemy.name);
                const lootPool = enemy.lootTable;
                console.log("Loot pool is:", lootPool);

                if (!lootPool || lootPool.length === 0) {
                    console.log("No loot table found for this enemy.");
                    return [];
                }
                
                const droppedItems = [];
                
                lootPool.forEach(itemID => {
                    const item = ITEM_DATABASE[itemID];
                    if (!item) {
                        console.warn("Item ID not found in database:", itemID);
                        return;
                    }
                    
                    const dropRate = (item.rarity === 'common') ? 0.60 : 0.40; 
                    
                    if (Math.random() < dropRate) {
                        playerInventory.push(itemID);
                        droppedItems.push(itemID);
                        console.log(`SUCCESS: Dropped ${itemID} (Rate: ${dropRate})`);
                    } else {
                        console.log(`FAILED: Did not drop ${itemID} (Rate: ${dropRate})`);
                    }
                });
                
                if (droppedItems.length === 0 && lootPool.length > 0) {
                    console.log("No items dropped, triggering guaranteed drop...");
                    const guaranteedItem = lootPool[Math.floor(Math.random() * lootPool.length)];
                    
                    playerInventory.push(guaranteedItem);
                    droppedItems.push(guaranteedItem);
                    
                    console.log(`GUARANTEED DROP: Forced drop of ${guaranteedItem}`);
                }
                
                console.log("Inventory updated:", playerInventory);
                return droppedItems;
            }
            

            // --- 10. level up
            function showLevelUpScreen() {
                battleScreen.classList.add('hidden');
                levelUpScreen.classList.remove('hidden');
                
                let remainingPoints = 50;
                let tempStats = { hp: 0, attack: 0, speed: 0 };
                
                const pointsText = document.getElementById('points-remaining-text');
                const hpCurrent = document.getElementById('hp-current-text');
                const hpAdded = document.getElementById('hp-added-text');
                const atkCurrent = document.getElementById('atk-current-text');
                const atkAdded = document.getElementById('atk-added-text');
                const spdCurrent = document.getElementById('spd-current-text');
                const spdAdded = document.getElementById('spd-added-text');
                const hpPlus = document.getElementById('hp-plus-btn');
                const hpMinus = document.getElementById('hp-minus-btn');
                const atkPlus = document.getElementById('atk-plus-btn');
                const atkMinus = document.getElementById('atk-minus-btn');
                const spdPlus = document.getElementById('spd-plus-btn');
                const spdMinus = document.getElementById('spd-minus-btn');
                const confirmBtn = document.getElementById('confirm-stats-button');

                function updateLevelUpUI() {
                    pointsText.textContent = remainingPoints;
                    hpCurrent.textContent = playerBaseStats.maxHp + tempStats.hp;
                    hpAdded.textContent = `(+${tempStats.hp})`;
                    atkCurrent.textContent = playerBaseStats.attack + tempStats.attack; 
                    atkAdded.textContent = `(+${tempStats.attack})`;
                    spdCurrent.textContent = playerBaseStats.speed + tempStats.speed;
                    spdAdded.textContent = `(+${tempStats.speed})`;
                    
                    hpPlus.disabled = (remainingPoints < 10);
                    atkPlus.disabled = (remainingPoints < 10);
                    spdPlus.disabled = (remainingPoints < 10);
                    
                    hpMinus.disabled = (tempStats.hp === 0);
                    atkMinus.disabled = (tempStats.attack === 0);
                    spdMinus.disabled = (tempStats.speed === 0);
                    confirmBtn.disabled = (remainingPoints > 0);
                }
                
                hpPlus.onclick = () => { if(remainingPoints >= 10) { remainingPoints -= 10; tempStats.hp += 10; updateLevelUpUI(); } };
                atkPlus.onclick = () => { if(remainingPoints >= 10) { remainingPoints -= 10; tempStats.attack += 10; updateLevelUpUI(); } };
                spdPlus.onclick = () => { if(remainingPoints >= 10) { remainingPoints -= 10; tempStats.speed += 10; updateLevelUpUI(); } };
                
                hpMinus.onclick = () => { if(tempStats.hp >= 10) { remainingPoints += 10; tempStats.hp -= 10; updateLevelUpUI(); } };
                atkMinus.onclick = () => { if(tempStats.attack >= 10) { remainingPoints += 10; tempStats.attack -= 10; updateLevelUpUI(); } };
                spdMinus.onclick = () => { if(tempStats.speed >= 10) { remainingPoints += 10; tempStats.speed -= 10; updateLevelUpUI(); } };

                confirmBtn.onclick = () => {
                    playerBaseStats.maxHp += tempStats.hp;
                    playerBaseStats.attack += tempStats.attack;
                    playerBaseStats.speed += tempStats.speed;
                    
                    levelUpScreen.classList.add('hidden');
                    stageSelectionScreen.classList.remove('hidden');
                };

                updateLevelUpUI();
            }

            // --- 11. back botten ---
            returnButton.addEventListener('click', () => {
                if (confirm("Are you sure you want to quit this battle and return to stage select?")) {
                    battleScreen.classList.add('hidden');
                    stageSelectionScreen.classList.remove('hidden');
                    isBattleOver = true; 
                }
            });
            
            // --- 12. items lists ---
            useItemButton.addEventListener('click', () => {
                openItemModal();
            });
            closeItemModalButton.addEventListener('click', () => {
                itemModalOverlay.classList.add('hidden');
            });

            function openItemModal() {
                itemModalList.innerHTML = ''; 
                
                const counts = {};
                playerInventory.forEach(item => { counts[item] = (counts[item] || 0) + 1; });
                
                if (Object.keys(counts).length === 0) {
                    itemModalList.innerHTML = '<li>No items.</li>';
                } else {
                    for (const itemId in counts) {
                        const item = ITEM_DATABASE[itemId];
                        const li = document.createElement('li');
                        const button = document.createElement('button');
                        button.className = 'item-modal-button';
                        button.innerHTML = `<strong>${item.name} (x${counts[itemId]})</strong><p>${item.description}</p>`;
                        
                        button.onclick = () => {
                            useItem(itemId);
                            itemModalOverlay.classList.add('hidden'); 
                        };
                        
                        li.appendChild(button);
                        itemModalList.appendChild(li);
                    }
                }
                itemModalOverlay.classList.remove('hidden');
            }

            function useItem(itemId) {
                const item = ITEM_DATABASE[itemId];
                if (!item) return;

                const itemIndex = playerInventory.indexOf(itemId);
                if (itemIndex > -1) {
                    playerInventory.splice(itemIndex, 1);
                } else {
                    return; 
                }

                const target = (itemId === 'spider_web' || itemId === 'spikes') ? enemy : player;
                const effectMessage = item.effect(target);

                updateUI();
                
                showActionPopup(`Item Used: <strong>${item.name}</strong>!<br>${effectMessage}`);
                logToScreen(`Item Used: ${item.name}.`, 'player');
            }

            // --- 13. go back to stage select ---
            stageSelectButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const stageId = button.dataset.stageId;
                    const enemyPool = STAGE_DATABASE[stageId];
                    if (!enemyPool) {
                        alert("Error: Stage not found!");
                        return;
                    }
                    
                    const randomEnemyId = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                    const selectedEnemy = ENEMY_DATABASE[randomEnemyId];

                    enemy = JSON.parse(JSON.stringify(selectedEnemy));
                    enemy.aiLogic = selectedEnemy.aiLogic; 
                    enemy.maxAp = MAX_AP;
                    enemy.currentAp = MAX_AP;
                    enemy.chargeTurns = 0;
                    enemy.isDefending = false;
                    enemy.isCountering = false;
                    enemy.isPoisoned = false;
                    enemy.isStunned = false;
                    enemy.isVulnerable = false;
                    enemy.speedBuffTurns = 0;
                    enemy.speedDebuffTurns = 0;
                    enemy.speedBuffPercent = 0;
                    enemy.speedDebuffPercent = 0;

                    player.maxHp = playerBaseStats.maxHp;
                    player.currentHp = playerBaseStats.maxHp;
                    player.attack = playerBaseStats.attack;
                    player.speed = playerBaseStats.speed;

                    player.currentAp = MAX_AP;
                    player.chargeTurns = 0;
                    player.isDefending = false;
                    player.isCountering = false;
                    player.isPoisoned = false;
                    player.isStunned = false;
                    player.isVulnerable = false;
                    player.speedBuffTurns = 0;
                    player.speedDebuffTurns = 0;
                    player.speedBuffPercent = 0;
                    player.speedDebuffPercent = 0;
                    
                    isBattleOver = false;
                    turnCount = 0; 
                    executeButton.disabled = false;
                    returnButton.disabled = false;
                    useItemButton.disabled = false;
                    
                    stageSelectionScreen.classList.add('hidden');
                    battleScreen.classList.remove('hidden');
                    
                    updateUI();
                    resetSlots();
                    battleLog.innerHTML = ''; 
                    logToScreen(`Battle Start! ${enemy.name} appears.`, 'system');
                });
            });

            updateUI();
        });
    </script>

</body>
</html>
